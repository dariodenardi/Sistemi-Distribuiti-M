# Sistemi Distribuiti M - 2021/2022

## 01.Modelli

###  (domanda provocatoria) Che cosa fa un laureato magistrale in ingegneria informatica in azienda oggi?

Comanda üòé

### Che cosa √® un componente?

E' un _pezzo di software_ che viene scritto dallo sviluppatore ed ha le seguenti caratteristiche:
- Contiene stato, metodi etc ma espone verso l'esterno solo quei metodi che si decidono che siano visibili all'esterno grazie all'uso di un'interfaccia;
- Viene eseguito all'interno di un _container_/_engine_/_middleware_.

Esempi di componenti sono quelli che si usano per creare le interfacce grafiche con **JavaFX**: _textBox_, _label_, _comboBox_ etc. Quando si clicca su un bottone non si verifica se effettivamente il _mouse_ √® sopra al tasto e lo si schiaccia ma si scrive solo il codice che deve essere eseguito se quel determinato evento si verifica.

- **Componente nel concentrato**: un componente che fa parte di un'applicazione che viene messa in esecuzione su una **sola** macchina;
- **Componente nel distribuito**: un concetto pi√π ampio rispetto a quello del concentrato. Il componente non √® vincolato a trovarsi su una sola macchina proprio per la definizione intrinseca di sistema distribuito. E' possibile spostarlo in qualsiasi momento da un nodo ad un altro. Per questo motivo il componente nel concentrato viene visto come se appartenesse ad un'applicazione "monolitica".

### Che differenza c'√® tra un componente ed un oggetto?
**Uguale all'oggetto**:

- Mantiene dettagli di come √® implementato: stato, metodi etc ed espone solo alcuni dei suoi dettagli tramite l'interfaccia;

**Diverso dall'oggetto**:
- Il componente viene eseguito all'interno di un _container_/_engine_/_middleware_ altrimenti non verrebbe eseguita la _funzione di callback_. Se si eseguisse il codice di un componente su una qualsiasi JVM non funzionerebbe. Riprendendo l'esempio di prima: chi √® che controlla che effettivamente il mouse √® posizionato sopra al bottone? Nessuno quindi il codice non potrebbe funzionare;
- Il componente √® di dimensioni pi√π grande di un oggetto  in termini di codice, perch√® il costo di overhead tra un'interazione e l'altra √® maggiore. Ipotizziamo che due componenti A e B interagiscano tra di loro. A per comunicare con B deve instaurare una connessione, scambiare i dati e alla fine chiuderla. Nel concentrato, invece, gli oggetti anche se sono piccoli e interagiscono spesso fra di loro non hanno questo problema di overhead.

Ovviamente bisogna stare attenti a creare un componente non troppo grande per evitare di andare incontro a tutti quei problemi affrontati durante il corso di Ingegneria del Software T (riusabilit√† etc).

### Che tipi di modelli possiamo utilizzare?

Ogni problema presenta una soluzione diversa. Per capire meglio come risolverli √® importante capire il funzionamento dei modelli.
I modelli che possono essere usati sono ad esempio:
- **Statici/dinamici**: sicuramente un sistema dinamico consente di adeguarsi a fronte di variazioni mentre un sistema statico no;
- **Preventivi/reattivi**: un sistema preventivo √® pi√π costoso di un sistema reattivo perch√® non √® detto che un evento si verifichi. Ad esempio, i sistemi operativi non utilizzano sistemi preventivi. Se avviene un deadlock tra processi lo si sblocca dall‚Äôesterno tramite linea di comando.

E' meglio una soluzione statica o dinamica? Meglio una soluzione preventiva o reattiva? La risposta in generale che deve fornire un ingegnere √® sempre: _dipende_. Ogni problema ha una storia diversa. Questo perch√® **non** esistono formule precise nei sistemi distribuiti dato che ci sono troppi parametri da prendere in considerazione: famiglia del processore, sistema operativo, linguaggio di programmazione etc.

### A cosa siamo interessati nei sistemi distribuiti?

Siamo interessati alle performance e ad eventuali colli di bottiglia. Per poterli evitare √® necessario osservare le performance dell'applicazione e solo in seguito si capisce che cosa andare a modificare. Ad esempio, aprire troppe connessioni con un DB pu√≤ introdurre un potenziale _bottleneck_.

Le modifiche non si effettuano sul codice stesso ma attraverso l'operazione di _deployment_ (dispiegamento). Ad esempio, installare tutte le librerie necessarie che servono all'applicazione, copiare i file che devono essere locali all‚Äôapplicazione, distribuire i componenti su uno o pi√π nodi e mettere davanti un bilanciatore di carico etc.
Quando faccio _deployment_ occorre decidere dove fare eseguire il componente e quali risorse ha bisogno per funzionare correttamente. Ad esempio, quando devo fare una Web App, ho un file che descrive queste scelte.

Come lo faccio? Ci sono diversi approcci:
- **Manuale**: l‚Äôutente determina ogni singolo oggetto/componente su quale √® il nodo pi√π appropriato;
- **File Script**: si devono eseguire alcuni file di script che racchiudono la sequenza dei comandi per arrivare alla configurazione che presenta le dipendenze;
- **Linguaggi dichiarativi**: supporto automatico alla configurazione attraverso linguaggi dichiarativi o modelli di funzionamento della configurazione da ottenere. Ad esempio, tramite il _file di deployment_ e annotazioni.

### Quali sono le sfide dell‚Äôenterprise computing?

- Portabilit√†;
- Interoperabilit√† fra diversi ambienti (anche _legacy_);
- Supporto e gestione runtime: scalabilit√†, efficienza, tolleranza ai guasti, resilienza, affidabilit√†, qualit√†, etc;
- Time-to-market: sviluppare componenti nel minor tempo possibile;
- Integrazione.

### Come sono evolute le architetture per le applicazioni enterprise?

Le architetture si sono evolute sempre di pi√π verso architettura N-tier perch√® l'obiettivo √® quello di separare logicamente le funzionalit√† in modo da ridurre la complessit√† degli strati:
- **Single-Tier**: c'√® un singolo calcolatore a cui sono connessi i clienti
    - **Vantaggi**: nessun aggiornamento dei clienti, una sola copia dei dati che si trova nel server;
    - **Svantaggi**: no scalabilit√†.
- **Two-Tier**:
- **Three-Tier**:

### Cos‚Äô√® J2EE?

E' un insieme di specifiche le cui implementazioni vengono principalmente sviluppate in linguaggio di programmazione Java e ampiamente utilizzata nella programmazione Web. Viene scritta solo la specifica non l‚Äôimplementazione, diversi produttori di software hanno fatto diverse implementazioni; purch√© siano JEE compliant basta che rispettino la specifica. Alcune implementazioni si limitano alla specifica altre aggiungono funzionalit√†.

Esistono diversi _software open source_, che vengono spesso usati anche in ambiente di produzione come:
- **GlassFish**: √® l'implementazione di riferimento mantenuta da Oracle;
- **WildFly**: precedentemente noto come JBoss.

### Come funzionano i modelli a contenimento?

Le chiamate clienti verso i metodi EJB sono intercettate dal container prima che questo le ‚Äúdeleghi‚Äù ai componenti EJB veri e propri.

---

## 02.EJB 2.x

### Che cos‚Äô√® EJB? Che caratteristiche offre? Che benefici offre EJB?

E' una tecnologia a componenti lato _server-side_ che consente di creare applicazioni distribuite che siano multi-tier, transazionali, portabili, scalabili, sicure, etc.

Permette di programmare tramite l'uso di componenti e di conseguenza porta tutti quei benefici che derivano da essi, si possono sfruttare tutti i servizi di sistema messi a disposizione dal container e lo si configura semplicemente grazie a un file .xml, detto _file descriptor_, in modo da non modificare nessuna riga di codice.

E' stata una delle prime tecnologie a componenti e al giorno d'oggi, sebbene c'√® ne siano molte altre, non √® da considerarsi completamente in disuso.

### Quali sono i principi di design di EJB?

- Le applicazioni EJB e i loro componenti devono essere debolmente accoppiati (_loosely coupled_). Ad esempio, se abbiamo due componenti A e B, A deve chiamare un metodo di B non molte volte. Questo perch√® nel distribuito abbiamo un costo di _overhead_ piuttosto alto. Dall'altra parte, i componenti devono essere portabili quindi bisogna stare attenti a come scrivere il software altrimenti diventa difficile ricostruire le sue dipendenze quando si decide di usare quel codice in un altro progetto;
- Il comportamento dei componenti EJB √® definito tramite interfacce. Aspetto assolutamente non nuovo perch√® basta pensare agli oggetti;
- Lo sviluppatore **non** deve pensare a come gestire le risorse. Ci pensa tutto il container;
- Le applicazioni EJB sono N-tier.

### Che problemi ha EJB 2.X?

- E' un container "pesante". Attualmente le tecnologie si sono spostate verso altre soluzioni;
- Modello di programmazione non tanto simile a quello che si usa per sviluppare oggetti classici;
- Difficolt√† di testing(?) In che senso? EJB 2.x o proprio di EJB in generale?.

### Quale √® la sua architettura?

![ejb2_architettura](./img/ebj2_architettura.png)

Sul'EJB Container non avr√≤ solo le istanze che il programmatore ha scritto ma anche altri due oggetti che vengono automaticamente generati:
- **Oggetto EJB Home**: implementa l‚Äôinterfaccia EJBHome. In terminologia J2EE si dice che il cliente implementa la Home Interface. √à un _proxy_ che intercetta la chiamata del cliente (la prima volta) e decide quale istanza logica gli deve restituire (una gi√† creata, nuova etc.);
- **Oggetto EJB Object**: implementa l‚Äôinterfaccia EJBObject. In terminologia J2EE si dice che il cliente implementa la Remote Interface. √à un _proxy_ che ha la stessa interfaccia del componente EJB creato dallo sviluppatore. Quando invoco un metodo chiamo l'EJBObject che invoca poi a sua volta il Java Bean.

E' bene ricordare che la macchina server non √® "pura" perch√© mi serve installarci sopra anche un container per far girare la mia applicazione.

Pensiamo di sviluppare un'applicazione riguardante una banca dove un utente pu√≤ solo prelevare e depositare soldi:
- **Sviluppatore**: creo solo una classe che chiamiamo Account. Al suo interno ci sono i metodi preleva e deposita. Non mi interessa niente riguardo le istanze, allocazione/deallocazione e thread. Scrivo il codice come se avessi solo un cliente. A tutto il resto ci pensa il container. In EJB 2.x ad ogni classe creata, dobbiamo anche creare due interfacce EJBHome e EJBObject perch√© cos√¨ che √® il contratto del cliente;
- **Cliente**: ipotizziamo di avere tre clienti: C1, C2 e C3 che richiedono tutti un prelievo. Per conoscere EJBHome √® importante che sia disponibile nel sistema dei nomi:
    - C1 fa richiesta di prelievo, dovr√† per prima cosa tramite il servizio di nomi ottenere EJBHome (in realt√† si ottiene lo _stub_). Dopo invoca su EJBHome _create()_/_find()_. La richiesta arriva a EJBHome (estensione di rmi.remote) che crea un oggetto O1 ed √® l‚Äôistanza logica dedicata per C1. EJBHome restituisce al cliente il riferimento di EJB Object (riferimento allo _stub_);
    - L‚Äôinvocazione del metodo prelievo verr√† fatta su EJBObject che a sua volta potr√† invocare l‚Äôoggetto O1;
    - C3 fa una richiesta. EJBHome potr√† creare un nuovo oggetto O2 oppure dare il riferimento di O1. Non √® detto che debba essere lo stesso.

### Quali contratti esistono?
Esistono due tipi di contratto:
- **Client view contract**: contratto tra cliente e container. Un contratto _client view_ √® costituito da:
    - **Home interface**: _proxy_ che funge da vera e propria factory;
    - **Object interface**: _proxy_ che ha gli stessi metodi di business;
    - **Identit√† dell'oggetto**? per arrivare alla home interface √® necessario un servizio di nomi che mi consente di recuperare la home interface
- **Component contract**: contratto tra componente e container. Il contratto serve a:
    - Abilitare le invocazioni dei metodi dei clienti;
    - Implementare le interfacce EJBHome e EJBObject per ridurre il carico di lavoro da parte dello sviluppatore;
    - Gestisce la persistenza (solo in EJB 2.x, da EJB 3.x la gestione cambia);
    - Gestisce tutti i servizi di sistema: sicurezza, transazionalit√† etc.;
    - Implementa il meccanismo delle callback. Ci sono i Message Driven Bean che vengono attivati quando si riceve un determinato messaggio.

### Di cosa si occupa l'EJB container?

- Genera automaticamente le classi concrete delle interfaccia EJBHome e EJBObject;
- Effettua il _binding_ dell‚Äôoggetto Home presso il
servizio di naming;
- Persistenza;
- Transazionalit√†;
- Gestione _lifecycle_ componenti;
- _Connection pooling_;
- _Threading_;
- Sicurezza.

### Quali sono le tipologie di componenti Bean?
I Bean possono essere classificati in due categorie:
- **Sincroni**: l'utente si blocca e aspetta la risposta da parte del _server_. Esistono due tipi di Bean:
    - **Session Bean**: a sua volta possiamo avere due tipi di Session Bean:
        - **Stateful**;
        - **Stateless**.
    - **Entity Bean**: a sua volta possiamo avere due tipi di Entity Bean:
        - **Container Managed Persistence (CMP)**;
        - **Bean Managed Persistence (BMP)**.
- **Asincroni**: l'utente non si blocca e non aspetta la risposta. Esiste un tipo di componente che fa parte di questa categoria:
    - **Message Driven Bean**.

### Cos‚Äô√® un Session Bean? Quando va usato? Che tipi di Session Bean esistono?

Un Session Bean ha le seguenti caratteristiche:
- Rappresenta un processo di business;
- Ogni cliente ha un'istanza;
- _Short-lived_: la vita del bean √® pari alla vita cliente o al massimo alla durata della sessione;
- Transient;
- No _fault-tollerant_: non sopravvive a crash del server;
- Pu√≤ avere propriet√† transazionali;
- Implementa l‚Äôinterfaccia _javax.ejb.SessionBean_.

Questo componente viene usato quando bisogna effettuare calcoli computazionali

I Session Bean che esistono sono di due tipi:
- **Stateless**: il componente √® privo di stato. Ad esempio, quando un'azione deve essere idempotente;
- **Statefull**: il componente √® con stato. Ad esempio, quando si aggiungono i prodotti in un carrello di e-commerce.

### Cos‚Äô√® un Entity Bean? Come si usano? Come pu√≤ essere gestita la persistenza?

Un Entity Bean ha le seguenti caratteristiche:
- Rappresenta i dati di business;
- L'stanza √® condivisa fra clienti diversi;
- Long-lived: la vita del bean √® pari a quella dei dati nel database;
- Persistente;
- Fault-tollerant: sopravvive a crash del server;
- Sempre transazionale;
- implementa l‚Äôinterfaccia _javax.ejb.EntityBean_.

Gli Entity Bean che esistono sono di due tipi:
- **Container Managed Persistence (CMP)**: persistenza gestita completamente dal container. Requisiti di persistenza specificati interamente nel descrittore di deployment;
- **Bean Managed Persistence (BMP)**: √® responsabilit√† dello sviluppatore la gestione della persistenza.

### Cosa sono e come funzionano i Message Driven Bean?

- Svolgono il ruolo di consumatori di messaggi asincroni;
- Non possono essere invocati direttamente dai clienti;
- Attivati in seguito all‚Äôarrivo di un messaggio;
- Non hanno interfacce EJBHome e EJBObject;
- I clienti possono interagire con i Message Driven Bean tramite l‚Äôinvio di messaggi verso le code o i topic per i quali questi componenti sono in ascolto (listener);
- Privi di stato.

### Che cosa sono le interfacce EJBHome ed EJBObject?

- **Interfaccia EJBHome**: √® un _proxy_ che intercetta la chiamata del cliente (la prima volta) e decide quale istanza logica gli deve restituire (una gi√† creata, nuova etc.). Al suo interno avremo i metodi per la creazione, il ritrovamento e la distruzione del bean. Tuttavia, il programmatore definisce solo l'interfaccia mentre l'oggetto √® implementato dal container. L'interfaccia pu√≤ essere remota e/o locale (vedi domande successive del perch√®).
Il cliente ottiene il riferimento all‚Äôoggetto _stub_
dell‚Äôoggetto EJBHome tramite JNDI;

- **Interfaccia EJBObject**: √à un _proxy_ che ha la stessa interfaccia del componente EJB creato dallo sviluppatore. Quando invoco un metodo chiamo l'EJBObject che invoca poi a sua volta il Java Bean. Il programmatore definisce solo l'interfaccia mentre l'oggetto √® implementato dal container. L'interfaccia pu√≤ essere remota o locale (vedi domande successive del perch√®).
Il cliente ottiene il riferimento all‚Äôoggetto _stub_ di EJBObject attraverso i metodi create() o find() dell‚Äôinterfaccia EJB Home.

### Come agisce un cliente in EJB 2.X?

Per interagire con un componente EJB il cliente deve:
- Ottenere l‚Äôoggetto EJBHome (in realt√† un oggetto _stub_ per l‚Äôoggetto EJBHome) via JNDI perch√® la comunicazione tra client e server avviene tramite RMI;
    - Creare l'oggetto InitialContext. Questo oggetto serve per poter cercare sul servizio di nomi;
    - Effettuare la lookup sul servizio di nomi;
    - Effettuare il narrowing;
- Dall‚Äôoggetto EJBHome, si invoca la _create()_ in modo da ottenere l'istanza logica dedicata dell'oggetto EJB desiderato. In realt√†, si ottiene un oggetto _stub_ per l‚Äôoggetto EJBObject per lo stesso motivo di prima;
- Invocare i metodi di business tramite l‚Äôoggetto EJB;
- Effettuare il clean up finale per liberare le risorse. Perch√® occupare un'istanza che non si usa?

### Come avviene l‚Äôinvocazione remota in EJB 2.X? Quali sono gli oggetti in gioco?

Per prima cosa bisogna implementare le interfacce EJBHome e EJBObject. Ovviamente gli oggetti che cooperano, in questo caso, si trovano su JVM differenti. Dal lato cliente vengono invocati i metodi di oggetti lato server e necessariamente ci deve essere un meccanismo di comunicazione tra cliente e server.

RMI √® utilizzato per la comunicazione fra cliente e server EJB. Le operazioni RMI sono costose perch√® bisogna effettuare la serializzazione/deserializzazione dei parametri, aprire, trasferire e chiudere una connessione RMI bastato su IIOP

In pi√π nello specifico dato che la comunicazione avviene con RMI su IIOP i passaggi sono i seguenti:

- Cliente:
    - Invoca un metodo dell‚Äôoggetto remoto
    - Lo _stub_ dell‚Äôoggetto remoto
        - ‚ÄúIntercetta‚Äù l‚Äôinvocazione di metodo
        - Effettua il _marshalling_ dei parametri
        - Effettua la chiamata vera e propria all‚Äôoggetto remoto
- Oggetto remoto:
    - Riceve l‚Äôinvocazione tramite il suo _skeleton_
    - Effettua l‚Äô_unmarshalling_ dei parametri
    - Esegue l‚Äôinvocazione localmente
    - Effettua il _marshalling_ dei risultati e li invia al cliente
- Lo _stub_ dell‚Äôoggetto remoto:
    - Riceve i risultati,effettua un marshalling e li restituisce al cliente

IIOP √® un protocollo di comunicazione del mondo CORBA.
c'√® una visione in RMI del mondo CORBA. Tuttavia, CORBA ha un suo standard.

### Come funziona l‚Äôuso locale di EJB?

Per prima cosa bisogna ricordarsi di implementare le interfacce EJBLocalHome e EJBLocalObject. Ovviamente, in questo caso i metodi non producono *RemoteException*.
Le interfacce locali, si usano quando il cliente esegue nella stessa JVM del componente EJB di interesse (e del suo container). Ad esempio, quando lo sviluppatore deve scrivere il codice. Non avrebbe senso pagare i costi di overhead sulla stessa macchina. In questo caso il passaggio dei parametri pu√≤ avvenire tramite riferimento proprio perch√® ci troviamo sulla stessa macchina

Inoltre, c'√® un'altro possibile uso per rendere pi√π efficiente il funzionamento di un Session Bean. Esso pu√≤ svolgere a sua volta il ruolo di "cliente local" verso altri bean.

Questa possibilit√† √® stata introdotta a partire da EJB2.0 anche se alcune implementazioni avevano gi√† delle ottimizzazioni senza che fosse inserito ufficialmente nello standard. Anche guardando lo _skeleton_ di RMI ha un'idea di ottimizzazione. Se √® locale evito di comunicare remotamente.

E' bene ricordare anche che non √® trasparente passare da EJBHome a EJBLocalHome perch√® l'interfaccia locale non ha la RemoteException

### Come avviene il deployment di una applicazione EJB?

Per effettuare il deployment di un'applicazione EJB sonno necessari i seguenti file:
- ***.EAR (Enterprise ARchive)**: √® tutta l'applicazione EJB che si trover√† lato server. Al suo interno abbiamo:
    - ***.WAR (Web ARchive)**: modulo Web (Servlet, JSP etc. ). E' facoltativo perch√® non √® detto che lo vogliamo inserire
    - **EJB-JAR (*.jar)**: modulo EJB. Per ogni componente EJB, il file ejb-jar deve contenere almeno i seguenti file:
        - **Classe bean**: classe scritta dallo sviluppatore
        - **Interfaccia EJBHome**:  a tempo di compilazione servono le interfacce mentre a tempo di esecuzione poi √® necessario che il container implementi lo _stub_
        - **Interfaccia EJBObject**: a tempo di compilazione servono le interfacce mentre a tempo di esecuzione poi √® necessario che il container implementi lo _stub_
        - **application.xml**: descrittore di deployment. La visibilit√† √® "locale" perch√® si limita all'interno del modulo

        Per effettuare il deployment di una applicazione EJB, √® sempre necessario creare un file *.EAR anche se l‚Äôapplicazione prevede un solo file EJB-JAR e nessun modulo Web. Tuttavia, alcuni container permettono il deployment diretto del solo modulo EJB-JAR senza dover creare il file *.EAR.

    - **application.xml**: descrittore di deployment. La visibilit√† √® "globale" paragonato a quello che si trova all'interno di ogni modulo.
- ***.JAR**: cliente EJB

---

## 03.Annotazioni

### Cosa sono le annotazioni? Esempi di annotazioni? Come sono strutturate?

Sono metadati con cui decoro i metodi, le classi, le interfacce etc. Non modificano il codice che lo sviluppatore scrive ma aggiungono solo informazioni che possono essere utili:
- Al compilatore;
- Alla _Javadoc_;
- A _runtime_.

Le annotazioni che sono state gi√† viste sicuramente in altri corsi sono le seguenti:
- **@Overrided**: serve a livello di compilazione. Se non mettessi questa annotazione, il codice verrebbe generato lo stesso per√≤ devo stare attento a come scrivo il nome del metodo sia nella classe padre che in quella figlia;
- **@Deprecated**: serve a livello di documentazione per indicare che quel metodo √® in disuso;
- **@SuppressWarnings**: serve a livello di compilazione. Se la compilazione presenta dei _warning_ questi vengono trascurati e non vengono mostrati all‚Äôutente.

Le annotazioni sono strutturate nel seguente modo: ci pu√≤ essere solo il nome dell'annotazione o in caso ci fossero dei membri vengono scritti come un insiemi di coppie nome=valore. Se il membro √® solo uno, il nome si pu√≤ omettere.

Con **membro** si intende il "parametro di ingresso" dell'annotazione.

### Perch√® si usano le annotazioni?

Le annotazioni consentono di arricchire lo spazio concettuale del linguaggio. Consente di fare programmazione dichiarativa oltre che a quella imperativa perch√® consente di associare delle informazioni in modo dichiarativo al codice non andando a modificare il comportamento dei metodi, delle classi etc. Ad esempio, quello che viene specificato con il *file di deployment* si pu√≤ fare benissimo tramite le annotazioni.

Sicuramente viene aggiunta una "parola" al codice per√≤ la logica di business non cambia.

### Quali categorie di annotazioni esistono?

- **Marker annotation**: non hanno membri. Ad esempio: @Override;
- **Single-value annotation**: hanno un solo membro. Ad esempio: @SuppressWarnings("unchecked");
- **Full annotation**: l'annotazione √® formata da piuÃÄ di un membro;
- **Custom annotation**: i programmatori possono crearsi le proprie annotazioni.

### Che limiti hanno le annotazioni personalizzate?

- **Non** si possono avere relazioni di estensione (_extends_) fra tipi di annotazioni;
- I tipi di ritorno degli eventuali metodi di una annotazioni devono essere: tipi primitivi, String, Class, enum, tipi di annotation o array dei tipi appena elencati;
- Una annotation **non** puoÃÄ lanciare eccezioni ovvero non puoÃÄ avere una _throws clause_;
- **Non** sono permessi _self-reference_. Ad esempio: AnnotationA non puoÃÄ contenere un membro di tipo AnnotationA;
- **Non** sono permessi _circular-reference_. Ad esempio: AnnotationA non puoÃÄ contenere un membro di tipo AnnotationB e quest'ultimo di AnnotationA.

### Cosa sono le meta-annotazioni? Quali sono?

Sono annotazioni che si specificano sulle annotazioni che vengono create. Le meta-annotazioni sono:

- **@Target**: specifica il tipo di elemento al quale si puoÃÄ allegare tale tipo di annotazione (campo, metodo, classe, interfaccia etc.);
- **@Documented**: specifica che le annotazioni di tale tipo faranno parte della Javadoc;
- **@Inherited**: questo tipo di annotazione funziona **solo** se apposta ad una classe. Il tipo di annotazione verraÃÄ automaticamente ereditato dalle sottoclassi della classe alla quale viene allegata;
- **@Retention**: politica di mantenimento in memoria con cui il compilatore e JVM devono gestire le annotazioni.

### Che valori possono avere le politiche di retention?

- **@Retention(RetentionPolicy.SOURCE)**: l'annotazione permane solo a livello di codice sorgente. Dunque, non viene memorizzata nel bytecode cio√® nel file .class. Viene utilizzata solo a tempo di sviluppo da parte del compilatore. Ad esempio, l'annotazione @Override. Se confrontassi la dimensione del file in cui l'annotazione √® stata scritta e quello in cui l'annotazione non √® stata scritta, potremmo vedere che √® la stessa;
- **@Retention(RetentionPolicy.CLASS)(default)**: l'annotazione verraÃÄ registrata nel bytecode ma non verraÃÄ mantenuta dalla JVM a runtime. Dunque, non si pu√≤ usare la reflection ma solo a tempo di caricamento. Ad esempio, si pu√≤ decidere come trattare il caricamento tramite il class loader del bytecode ma poi le annotazioni non si possono sono usate a run-time
- **@Retention(RetentionPolicy.RUNTIME)**: l'annotazione verraÃÄ registrata nel bytecode e potraÃÄ essere letta a runtime tramite reflection anche dopo il caricamento della classe da parte della JVM. E' utilizzabile anche all‚Äôinterno del codice di supporto/applicativo a tempo di esecuzione, con proprietaÃÄ eventualmente modificabili a runtime.

## 04.Sistemi di Nomi

### Cos‚Äô√® un servizio di naming? Cos‚Äô√® e cosa fa JNDI?

Sistema di nomi: RMI Registry (RMI), DNS, Port Mapper (RPC)

Nome logico, numero di programma, numero di protocollo -> porta

### Cos‚Äô√® un protocollo di discovery? Fornire un esempio

Discovery: es. bluetooth protocollo di discovery. mando dei broadcast ma non so se gli altri dispositivi hanno il bluetooth

### Cosa sono le directory? Come sono fatte? Fornire un esempio

Directory: LDAP, es. accesso ai laboratori di UNIBO

### Quali sono i concetti fondamentali in JNDI?
### Cos‚Äô√® un provider JNDI? Cos‚Äô√® l‚Äôinterfaccia Context e che metodi ha? Esempi di sotto-
interfacce di Context?
### Esempio di uso di JNDI? Come si possono memorizzare i dati in JNDI?
### Configurazione di JNDI?

```
@Target ( {ElementType.METHOD,ElementType.PACKAGE} )
public @interface ExampleAnnotation { ... }
```